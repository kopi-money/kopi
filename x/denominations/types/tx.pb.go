// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: kopi/denominations/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{0}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

type MsgAddDEXDenom struct {
	Authority    string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Factor       string `protobuf:"bytes,3,opt,name=factor,proto3" json:"factor,omitempty"`
	MinLiquidity string `protobuf:"bytes,4,opt,name=min_liquidity,json=minLiquidity,proto3" json:"min_liquidity,omitempty"`
}

func (m *MsgAddDEXDenom) Reset()         { *m = MsgAddDEXDenom{} }
func (m *MsgAddDEXDenom) String() string { return proto.CompactTextString(m) }
func (*MsgAddDEXDenom) ProtoMessage()    {}
func (*MsgAddDEXDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{1}
}
func (m *MsgAddDEXDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddDEXDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddDEXDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddDEXDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddDEXDenom.Merge(m, src)
}
func (m *MsgAddDEXDenom) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddDEXDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddDEXDenom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddDEXDenom proto.InternalMessageInfo

func (m *MsgAddDEXDenom) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddDEXDenom) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgAddDEXDenom) GetFactor() string {
	if m != nil {
		return m.Factor
	}
	return ""
}

func (m *MsgAddDEXDenom) GetMinLiquidity() string {
	if m != nil {
		return m.MinLiquidity
	}
	return ""
}

type MsgUpdateDEXDenom struct {
	Authority    string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	MinLiquidity string `protobuf:"bytes,3,opt,name=min_liquidity,json=minLiquidity,proto3" json:"min_liquidity,omitempty"`
}

func (m *MsgUpdateDEXDenom) Reset()         { *m = MsgUpdateDEXDenom{} }
func (m *MsgUpdateDEXDenom) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateDEXDenom) ProtoMessage()    {}
func (*MsgUpdateDEXDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{2}
}
func (m *MsgUpdateDEXDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateDEXDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateDEXDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateDEXDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateDEXDenom.Merge(m, src)
}
func (m *MsgUpdateDEXDenom) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateDEXDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateDEXDenom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateDEXDenom proto.InternalMessageInfo

func (m *MsgUpdateDEXDenom) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateDEXDenom) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateDEXDenom) GetMinLiquidity() string {
	if m != nil {
		return m.MinLiquidity
	}
	return ""
}

type MsgAddKCoin struct {
	Authority     string   `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom         string   `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	References    []string `protobuf:"bytes,3,rep,name=references,proto3" json:"references,omitempty"`
	MaxSupply     string   `protobuf:"bytes,4,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"`
	MaxMintAmount string   `protobuf:"bytes,5,opt,name=max_mint_amount,json=maxMintAmount,proto3" json:"max_mint_amount,omitempty"`
	MaxBurnAmount string   `protobuf:"bytes,6,opt,name=max_burn_amount,json=maxBurnAmount,proto3" json:"max_burn_amount,omitempty"`
	Factor        string   `protobuf:"bytes,7,opt,name=factor,proto3" json:"factor,omitempty"`
	MinLiquidity  string   `protobuf:"bytes,8,opt,name=min_liquidity,json=minLiquidity,proto3" json:"min_liquidity,omitempty"`
}

func (m *MsgAddKCoin) Reset()         { *m = MsgAddKCoin{} }
func (m *MsgAddKCoin) String() string { return proto.CompactTextString(m) }
func (*MsgAddKCoin) ProtoMessage()    {}
func (*MsgAddKCoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{3}
}
func (m *MsgAddKCoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddKCoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddKCoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddKCoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddKCoin.Merge(m, src)
}
func (m *MsgAddKCoin) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddKCoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddKCoin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddKCoin proto.InternalMessageInfo

func (m *MsgAddKCoin) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddKCoin) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgAddKCoin) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *MsgAddKCoin) GetMaxSupply() string {
	if m != nil {
		return m.MaxSupply
	}
	return ""
}

func (m *MsgAddKCoin) GetMaxMintAmount() string {
	if m != nil {
		return m.MaxMintAmount
	}
	return ""
}

func (m *MsgAddKCoin) GetMaxBurnAmount() string {
	if m != nil {
		return m.MaxBurnAmount
	}
	return ""
}

func (m *MsgAddKCoin) GetFactor() string {
	if m != nil {
		return m.Factor
	}
	return ""
}

func (m *MsgAddKCoin) GetMinLiquidity() string {
	if m != nil {
		return m.MinLiquidity
	}
	return ""
}

type MsgUpdateKCoinSupply struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom     string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MaxSupply string `protobuf:"bytes,3,opt,name=max_supply,json=maxSupply,proto3" json:"max_supply,omitempty"`
}

func (m *MsgUpdateKCoinSupply) Reset()         { *m = MsgUpdateKCoinSupply{} }
func (m *MsgUpdateKCoinSupply) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateKCoinSupply) ProtoMessage()    {}
func (*MsgUpdateKCoinSupply) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{4}
}
func (m *MsgUpdateKCoinSupply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateKCoinSupply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateKCoinSupply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateKCoinSupply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateKCoinSupply.Merge(m, src)
}
func (m *MsgUpdateKCoinSupply) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateKCoinSupply) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateKCoinSupply.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateKCoinSupply proto.InternalMessageInfo

func (m *MsgUpdateKCoinSupply) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateKCoinSupply) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateKCoinSupply) GetMaxSupply() string {
	if m != nil {
		return m.MaxSupply
	}
	return ""
}

type MsgUpdateKCoinBurnAmount struct {
	Authority     string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom         string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MaxBurnAmount string `protobuf:"bytes,3,opt,name=max_burn_amount,json=maxBurnAmount,proto3" json:"max_burn_amount,omitempty"`
}

func (m *MsgUpdateKCoinBurnAmount) Reset()         { *m = MsgUpdateKCoinBurnAmount{} }
func (m *MsgUpdateKCoinBurnAmount) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateKCoinBurnAmount) ProtoMessage()    {}
func (*MsgUpdateKCoinBurnAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{5}
}
func (m *MsgUpdateKCoinBurnAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateKCoinBurnAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateKCoinBurnAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateKCoinBurnAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateKCoinBurnAmount.Merge(m, src)
}
func (m *MsgUpdateKCoinBurnAmount) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateKCoinBurnAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateKCoinBurnAmount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateKCoinBurnAmount proto.InternalMessageInfo

func (m *MsgUpdateKCoinBurnAmount) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateKCoinBurnAmount) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateKCoinBurnAmount) GetMaxBurnAmount() string {
	if m != nil {
		return m.MaxBurnAmount
	}
	return ""
}

type MsgUpdateKCoinMintAmount struct {
	Authority     string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom         string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MaxMintAmount string `protobuf:"bytes,3,opt,name=max_mint_amount,json=maxMintAmount,proto3" json:"max_mint_amount,omitempty"`
}

func (m *MsgUpdateKCoinMintAmount) Reset()         { *m = MsgUpdateKCoinMintAmount{} }
func (m *MsgUpdateKCoinMintAmount) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateKCoinMintAmount) ProtoMessage()    {}
func (*MsgUpdateKCoinMintAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{6}
}
func (m *MsgUpdateKCoinMintAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateKCoinMintAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateKCoinMintAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateKCoinMintAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateKCoinMintAmount.Merge(m, src)
}
func (m *MsgUpdateKCoinMintAmount) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateKCoinMintAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateKCoinMintAmount.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateKCoinMintAmount proto.InternalMessageInfo

func (m *MsgUpdateKCoinMintAmount) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateKCoinMintAmount) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateKCoinMintAmount) GetMaxMintAmount() string {
	if m != nil {
		return m.MaxMintAmount
	}
	return ""
}

type MsgAddKCoinReferences struct {
	Authority  string   `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom      string   `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	References []string `protobuf:"bytes,3,rep,name=references,proto3" json:"references,omitempty"`
}

func (m *MsgAddKCoinReferences) Reset()         { *m = MsgAddKCoinReferences{} }
func (m *MsgAddKCoinReferences) String() string { return proto.CompactTextString(m) }
func (*MsgAddKCoinReferences) ProtoMessage()    {}
func (*MsgAddKCoinReferences) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{7}
}
func (m *MsgAddKCoinReferences) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddKCoinReferences) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddKCoinReferences.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddKCoinReferences) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddKCoinReferences.Merge(m, src)
}
func (m *MsgAddKCoinReferences) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddKCoinReferences) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddKCoinReferences.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddKCoinReferences proto.InternalMessageInfo

func (m *MsgAddKCoinReferences) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddKCoinReferences) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgAddKCoinReferences) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

type MsgRemoveKCoinReferences struct {
	Authority  string   `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom      string   `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	References []string `protobuf:"bytes,3,rep,name=references,proto3" json:"references,omitempty"`
}

func (m *MsgRemoveKCoinReferences) Reset()         { *m = MsgRemoveKCoinReferences{} }
func (m *MsgRemoveKCoinReferences) String() string { return proto.CompactTextString(m) }
func (*MsgRemoveKCoinReferences) ProtoMessage()    {}
func (*MsgRemoveKCoinReferences) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{8}
}
func (m *MsgRemoveKCoinReferences) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRemoveKCoinReferences) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRemoveKCoinReferences.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRemoveKCoinReferences) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRemoveKCoinReferences.Merge(m, src)
}
func (m *MsgRemoveKCoinReferences) XXX_Size() int {
	return m.Size()
}
func (m *MsgRemoveKCoinReferences) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRemoveKCoinReferences.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRemoveKCoinReferences proto.InternalMessageInfo

func (m *MsgRemoveKCoinReferences) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRemoveKCoinReferences) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgRemoveKCoinReferences) GetReferences() []string {
	if m != nil {
		return m.References
	}
	return nil
}

type MsgAddCollateralDenom struct {
	Authority  string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom      string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Ltv        string `protobuf:"bytes,3,opt,name=ltv,proto3" json:"ltv,omitempty"`
	MaxDeposit string `protobuf:"bytes,4,opt,name=max_deposit,json=maxDeposit,proto3" json:"max_deposit,omitempty"`
}

func (m *MsgAddCollateralDenom) Reset()         { *m = MsgAddCollateralDenom{} }
func (m *MsgAddCollateralDenom) String() string { return proto.CompactTextString(m) }
func (*MsgAddCollateralDenom) ProtoMessage()    {}
func (*MsgAddCollateralDenom) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{9}
}
func (m *MsgAddCollateralDenom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddCollateralDenom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddCollateralDenom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddCollateralDenom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddCollateralDenom.Merge(m, src)
}
func (m *MsgAddCollateralDenom) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddCollateralDenom) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddCollateralDenom.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddCollateralDenom proto.InternalMessageInfo

func (m *MsgAddCollateralDenom) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddCollateralDenom) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgAddCollateralDenom) GetLtv() string {
	if m != nil {
		return m.Ltv
	}
	return ""
}

func (m *MsgAddCollateralDenom) GetMaxDeposit() string {
	if m != nil {
		return m.MaxDeposit
	}
	return ""
}

type MsgUpdateCollateralDenomLTV struct {
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom     string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Ltv       string `protobuf:"bytes,3,opt,name=ltv,proto3" json:"ltv,omitempty"`
}

func (m *MsgUpdateCollateralDenomLTV) Reset()         { *m = MsgUpdateCollateralDenomLTV{} }
func (m *MsgUpdateCollateralDenomLTV) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollateralDenomLTV) ProtoMessage()    {}
func (*MsgUpdateCollateralDenomLTV) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{10}
}
func (m *MsgUpdateCollateralDenomLTV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollateralDenomLTV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollateralDenomLTV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollateralDenomLTV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollateralDenomLTV.Merge(m, src)
}
func (m *MsgUpdateCollateralDenomLTV) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollateralDenomLTV) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollateralDenomLTV.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollateralDenomLTV proto.InternalMessageInfo

func (m *MsgUpdateCollateralDenomLTV) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateCollateralDenomLTV) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateCollateralDenomLTV) GetLtv() string {
	if m != nil {
		return m.Ltv
	}
	return ""
}

type MsgUpdateCollateralDenomMaxDeposit struct {
	Authority  string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Denom      string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	MaxDeposit string `protobuf:"bytes,3,opt,name=max_deposit,json=maxDeposit,proto3" json:"max_deposit,omitempty"`
}

func (m *MsgUpdateCollateralDenomMaxDeposit) Reset()         { *m = MsgUpdateCollateralDenomMaxDeposit{} }
func (m *MsgUpdateCollateralDenomMaxDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCollateralDenomMaxDeposit) ProtoMessage()    {}
func (*MsgUpdateCollateralDenomMaxDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{11}
}
func (m *MsgUpdateCollateralDenomMaxDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCollateralDenomMaxDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCollateralDenomMaxDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCollateralDenomMaxDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCollateralDenomMaxDeposit.Merge(m, src)
}
func (m *MsgUpdateCollateralDenomMaxDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCollateralDenomMaxDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCollateralDenomMaxDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCollateralDenomMaxDeposit proto.InternalMessageInfo

func (m *MsgUpdateCollateralDenomMaxDeposit) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateCollateralDenomMaxDeposit) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *MsgUpdateCollateralDenomMaxDeposit) GetMaxDeposit() string {
	if m != nil {
		return m.MaxDeposit
	}
	return ""
}

type MsgAddCAsset struct {
	Authority    string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Name         string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	BaseDenom    string `protobuf:"bytes,3,opt,name=base_denom,json=baseDenom,proto3" json:"base_denom,omitempty"`
	DexFeeShare  string `protobuf:"bytes,4,opt,name=dex_fee_share,json=dexFeeShare,proto3" json:"dex_fee_share,omitempty"`
	Factor       string `protobuf:"bytes,5,opt,name=factor,proto3" json:"factor,omitempty"`
	MinLiquidity string `protobuf:"bytes,6,opt,name=min_liquidity,json=minLiquidity,proto3" json:"min_liquidity,omitempty"`
	BorrowLimit  string `protobuf:"bytes,7,opt,name=borrow_limit,json=borrowLimit,proto3" json:"borrow_limit,omitempty"`
}

func (m *MsgAddCAsset) Reset()         { *m = MsgAddCAsset{} }
func (m *MsgAddCAsset) String() string { return proto.CompactTextString(m) }
func (*MsgAddCAsset) ProtoMessage()    {}
func (*MsgAddCAsset) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{12}
}
func (m *MsgAddCAsset) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddCAsset) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddCAsset.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddCAsset) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddCAsset.Merge(m, src)
}
func (m *MsgAddCAsset) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddCAsset) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddCAsset.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddCAsset proto.InternalMessageInfo

func (m *MsgAddCAsset) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgAddCAsset) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgAddCAsset) GetBaseDenom() string {
	if m != nil {
		return m.BaseDenom
	}
	return ""
}

func (m *MsgAddCAsset) GetDexFeeShare() string {
	if m != nil {
		return m.DexFeeShare
	}
	return ""
}

func (m *MsgAddCAsset) GetFactor() string {
	if m != nil {
		return m.Factor
	}
	return ""
}

func (m *MsgAddCAsset) GetMinLiquidity() string {
	if m != nil {
		return m.MinLiquidity
	}
	return ""
}

func (m *MsgAddCAsset) GetBorrowLimit() string {
	if m != nil {
		return m.BorrowLimit
	}
	return ""
}

type MsgUpdateCAssetDexFeeShare struct {
	Authority   string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	DexFeeShare string `protobuf:"bytes,3,opt,name=dex_fee_share,json=dexFeeShare,proto3" json:"dex_fee_share,omitempty"`
}

func (m *MsgUpdateCAssetDexFeeShare) Reset()         { *m = MsgUpdateCAssetDexFeeShare{} }
func (m *MsgUpdateCAssetDexFeeShare) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCAssetDexFeeShare) ProtoMessage()    {}
func (*MsgUpdateCAssetDexFeeShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{13}
}
func (m *MsgUpdateCAssetDexFeeShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCAssetDexFeeShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCAssetDexFeeShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCAssetDexFeeShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCAssetDexFeeShare.Merge(m, src)
}
func (m *MsgUpdateCAssetDexFeeShare) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCAssetDexFeeShare) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCAssetDexFeeShare.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCAssetDexFeeShare proto.InternalMessageInfo

func (m *MsgUpdateCAssetDexFeeShare) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateCAssetDexFeeShare) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateCAssetDexFeeShare) GetDexFeeShare() string {
	if m != nil {
		return m.DexFeeShare
	}
	return ""
}

type MsgUpdateCAssetBorrowLimit struct {
	Authority   string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	BorrowLimit string `protobuf:"bytes,3,opt,name=borrow_limit,json=borrowLimit,proto3" json:"borrow_limit,omitempty"`
}

func (m *MsgUpdateCAssetBorrowLimit) Reset()         { *m = MsgUpdateCAssetBorrowLimit{} }
func (m *MsgUpdateCAssetBorrowLimit) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCAssetBorrowLimit) ProtoMessage()    {}
func (*MsgUpdateCAssetBorrowLimit) Descriptor() ([]byte, []int) {
	return fileDescriptor_6ba97ecacef12ed2, []int{14}
}
func (m *MsgUpdateCAssetBorrowLimit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCAssetBorrowLimit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCAssetBorrowLimit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCAssetBorrowLimit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCAssetBorrowLimit.Merge(m, src)
}
func (m *MsgUpdateCAssetBorrowLimit) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCAssetBorrowLimit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCAssetBorrowLimit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCAssetBorrowLimit proto.InternalMessageInfo

func (m *MsgUpdateCAssetBorrowLimit) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateCAssetBorrowLimit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgUpdateCAssetBorrowLimit) GetBorrowLimit() string {
	if m != nil {
		return m.BorrowLimit
	}
	return ""
}

func init() {
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "kopi.denominations.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgAddDEXDenom)(nil), "kopi.denominations.MsgAddDEXDenom")
	proto.RegisterType((*MsgUpdateDEXDenom)(nil), "kopi.denominations.MsgUpdateDEXDenom")
	proto.RegisterType((*MsgAddKCoin)(nil), "kopi.denominations.MsgAddKCoin")
	proto.RegisterType((*MsgUpdateKCoinSupply)(nil), "kopi.denominations.MsgUpdateKCoinSupply")
	proto.RegisterType((*MsgUpdateKCoinBurnAmount)(nil), "kopi.denominations.MsgUpdateKCoinBurnAmount")
	proto.RegisterType((*MsgUpdateKCoinMintAmount)(nil), "kopi.denominations.MsgUpdateKCoinMintAmount")
	proto.RegisterType((*MsgAddKCoinReferences)(nil), "kopi.denominations.MsgAddKCoinReferences")
	proto.RegisterType((*MsgRemoveKCoinReferences)(nil), "kopi.denominations.MsgRemoveKCoinReferences")
	proto.RegisterType((*MsgAddCollateralDenom)(nil), "kopi.denominations.MsgAddCollateralDenom")
	proto.RegisterType((*MsgUpdateCollateralDenomLTV)(nil), "kopi.denominations.MsgUpdateCollateralDenomLTV")
	proto.RegisterType((*MsgUpdateCollateralDenomMaxDeposit)(nil), "kopi.denominations.MsgUpdateCollateralDenomMaxDeposit")
	proto.RegisterType((*MsgAddCAsset)(nil), "kopi.denominations.MsgAddCAsset")
	proto.RegisterType((*MsgUpdateCAssetDexFeeShare)(nil), "kopi.denominations.MsgUpdateCAssetDexFeeShare")
	proto.RegisterType((*MsgUpdateCAssetBorrowLimit)(nil), "kopi.denominations.MsgUpdateCAssetBorrowLimit")
}

func init() { proto.RegisterFile("kopi/denominations/tx.proto", fileDescriptor_6ba97ecacef12ed2) }

var fileDescriptor_6ba97ecacef12ed2 = []byte{
	// 1056 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xae, 0xeb, 0x6d, 0xd9, 0xbe, 0xb4, 0x0b, 0xb5, 0xba, 0x34, 0x9b, 0xd5, 0xa6, 0x5d, 0xaf,
	0x58, 0x75, 0x0b, 0x4d, 0x16, 0x16, 0x2d, 0x22, 0x02, 0x89, 0xa6, 0x85, 0xc3, 0xd2, 0x48, 0x28,
	0x05, 0xb4, 0xda, 0x03, 0x91, 0x53, 0x4f, 0xd3, 0x81, 0xcc, 0x8c, 0xf1, 0x4c, 0x4a, 0x7a, 0x43,
	0x1c, 0x38, 0x70, 0xe2, 0x1f, 0xf0, 0x17, 0x2a, 0xc1, 0x1d, 0x81, 0x38, 0x20, 0x2e, 0x94, 0xbd,
	0xc0, 0x01, 0x09, 0xd4, 0x1e, 0xfa, 0x37, 0x90, 0xc7, 0x6e, 0xec, 0x78, 0x1c, 0xa7, 0x4e, 0x53,
	0xf6, 0xb2, 0x6b, 0xbf, 0xf7, 0x79, 0xde, 0xf7, 0xbd, 0xf7, 0x9c, 0xf7, 0x5c, 0xb8, 0xf9, 0x19,
	0x73, 0x70, 0xd9, 0x46, 0x94, 0x11, 0x4c, 0x2d, 0x81, 0x19, 0xe5, 0x65, 0xd1, 0x2d, 0x39, 0x2e,
	0x13, 0xcc, 0x30, 0x3c, 0x67, 0xa9, 0xcf, 0x59, 0x98, 0xb7, 0x08, 0xa6, 0xac, 0x2c, 0xff, 0xf5,
	0x61, 0x85, 0xc5, 0x1d, 0xc6, 0x09, 0xe3, 0x65, 0xc2, 0x5b, 0xe5, 0xfd, 0x57, 0xbd, 0xff, 0x02,
	0xc7, 0x0d, 0xdf, 0xd1, 0x90, 0x77, 0x65, 0xff, 0x26, 0x70, 0x2d, 0xb4, 0x58, 0x8b, 0xf9, 0x76,
	0xef, 0x2a, 0xb0, 0x2e, 0x25, 0xb0, 0x71, 0x2c, 0xd7, 0x22, 0xc1, 0x63, 0xe6, 0x0d, 0x58, 0xac,
	0xf1, 0xd6, 0x47, 0x8e, 0x6d, 0x09, 0xf4, 0x81, 0x74, 0xd4, 0x11, 0x77, 0x18, 0xe5, 0xc8, 0xfc,
	0x43, 0x83, 0x6b, 0x35, 0xde, 0x5a, 0xb7, 0xed, 0xcd, 0x77, 0x1f, 0x6f, 0x7a, 0x47, 0x18, 0x0f,
	0x61, 0xc6, 0xea, 0x88, 0x3d, 0xe6, 0x62, 0x71, 0x90, 0xd7, 0x96, 0xb5, 0x95, 0x99, 0x6a, 0xfe,
	0xe9, 0x0f, 0x6b, 0x0b, 0x01, 0x93, 0x75, 0xdb, 0x76, 0x11, 0xe7, 0xdb, 0xc2, 0xc5, 0xb4, 0x55,
	0x0f, 0xa1, 0x86, 0x01, 0x57, 0xa8, 0x45, 0x50, 0x7e, 0xd2, 0x7b, 0xa4, 0x2e, 0xaf, 0x8d, 0x17,
	0x61, 0x7a, 0xd7, 0xda, 0x11, 0xcc, 0xcd, 0xeb, 0xd2, 0x1a, 0xdc, 0x19, 0x77, 0x60, 0x8e, 0x60,
	0xda, 0x68, 0xe3, 0xcf, 0x3b, 0xd8, 0xf6, 0xe2, 0x5c, 0x91, 0xee, 0x59, 0x82, 0xe9, 0xd6, 0x99,
	0xad, 0xf2, 0xf0, 0xab, 0xd3, 0xc3, 0xd5, 0x30, 0xc0, 0x37, 0xa7, 0x87, 0xab, 0x77, 0xa4, 0xd4,
	0x6e, 0x4c, 0x6c, 0xbf, 0x00, 0xf3, 0x47, 0x0d, 0xe6, 0x7b, 0x7a, 0x2f, 0x45, 0x96, 0x42, 0x5f,
	0x4f, 0xa0, 0xff, 0xa6, 0x4a, 0xff, 0xee, 0x20, 0xfa, 0xfd, 0x5c, 0xcd, 0xbf, 0x27, 0x21, 0xe7,
	0x8b, 0x7a, 0x7f, 0x83, 0x61, 0x3a, 0x32, 0xf7, 0x05, 0x98, 0x92, 0xa1, 0x02, 0xf2, 0xfe, 0x8d,
	0x51, 0x04, 0x70, 0xd1, 0x2e, 0x72, 0x11, 0xdd, 0x41, 0x3c, 0xaf, 0x2f, 0xeb, 0x2b, 0x33, 0xf5,
	0x88, 0xc5, 0xb8, 0x05, 0x40, 0xac, 0x6e, 0x83, 0x77, 0x1c, 0xa7, 0x7d, 0x56, 0x99, 0x19, 0x62,
	0x75, 0xb7, 0xa5, 0xc1, 0xb8, 0x0b, 0xcf, 0x7b, 0x6e, 0x82, 0xa9, 0x68, 0x58, 0x84, 0x75, 0xa8,
	0xc8, 0x4f, 0x49, 0xcc, 0x1c, 0xb1, 0xba, 0x35, 0x4c, 0xc5, 0xba, 0x34, 0x9e, 0xe1, 0x9a, 0x1d,
	0x97, 0x9e, 0xe1, 0xa6, 0x7b, 0xb8, 0x6a, 0xc7, 0xa5, 0x01, 0x2e, 0xec, 0x91, 0xe7, 0xd2, 0x7b,
	0xe4, 0x6a, 0x42, 0x92, 0x1f, 0xa8, 0x49, 0x5e, 0x4e, 0xe9, 0x11, 0x99, 0x4e, 0xf3, 0x27, 0x0d,
	0x16, 0x7a, 0x49, 0x97, 0xa6, 0x40, 0xda, 0x78, 0xf3, 0xdc, 0x9f, 0x47, 0x3d, 0x96, 0xc7, 0xca,
	0x5b, 0x2a, 0xf5, 0x7b, 0xe9, 0xfd, 0x11, 0xa1, 0x6a, 0x3e, 0xd5, 0x20, 0xdf, 0xef, 0x88, 0xa4,
	0x74, 0xbc, 0x3a, 0x12, 0x0a, 0xa9, 0x27, 0x14, 0xb2, 0xf2, 0x8e, 0x2a, 0x68, 0xed, 0x1c, 0x82,
	0xc2, 0x13, 0x12, 0x44, 0x45, 0xfa, 0xe9, 0x52, 0x44, 0x45, 0xbb, 0x58, 0x4f, 0xe8, 0xe2, 0x51,
	0x45, 0x85, 0x27, 0x98, 0xbf, 0x68, 0x70, 0x3d, 0xd2, 0x7d, 0xf5, 0xf0, 0x45, 0xfb, 0x5f, 0x5f,
	0xeb, 0xca, 0xdb, 0xaa, 0x92, 0xd5, 0x61, 0xaf, 0x4a, 0x48, 0xd6, 0xfc, 0xcd, 0xaf, 0x4d, 0x1d,
	0x11, 0xb6, 0x8f, 0x9e, 0xad, 0x92, 0x2c, 0x35, 0x49, 0xe4, 0x6b, 0xfe, 0xd9, 0xab, 0xc9, 0x06,
	0x6b, 0xb7, 0x2d, 0x81, 0x5c, 0xab, 0x7d, 0xb1, 0x31, 0x91, 0xac, 0xe4, 0x05, 0xd0, 0xdb, 0x62,
	0x3f, 0xe8, 0x2c, 0xef, 0xd2, 0x58, 0x82, 0x9c, 0xd7, 0x77, 0x36, 0x72, 0x18, 0xc7, 0x22, 0xf8,
	0x75, 0xf5, 0x7e, 0x27, 0x36, 0x7d, 0x4b, 0xd6, 0x32, 0xc5, 0xf8, 0x9b, 0x3f, 0x6b, 0x70, 0xb3,
	0xd7, 0x8a, 0x31, 0xe7, 0xd6, 0x87, 0x1f, 0x5f, 0xb6, 0xbe, 0xca, 0x86, 0x4a, 0xff, 0x7e, 0xfa,
	0xfb, 0xa2, 0x92, 0x34, 0xff, 0xd1, 0xc0, 0x1c, 0xe4, 0xaf, 0xf5, 0x52, 0x35, 0x66, 0x2d, 0xb1,
	0xca, 0xe8, 0x4a, 0x65, 0x1e, 0xa9, 0xd2, 0xde, 0xc8, 0x24, 0x2d, 0xa4, 0x6e, 0x7e, 0x3f, 0x09,
	0xb3, 0x41, 0x01, 0xd7, 0x39, 0x47, 0x62, 0xac, 0xeb, 0xc9, 0x2d, 0x80, 0xa6, 0xc5, 0x51, 0xc3,
	0x17, 0x19, 0x0c, 0x1e, 0xcf, 0xe2, 0xb7, 0xb8, 0x09, 0x73, 0x36, 0xea, 0x36, 0x76, 0x11, 0x6a,
	0xf0, 0x3d, 0xcb, 0x45, 0x41, 0x13, 0xe6, 0x6c, 0xd4, 0x7d, 0x0f, 0xa1, 0x6d, 0xcf, 0x14, 0x19,
	0xca, 0x53, 0xe9, 0x43, 0x79, 0x5a, 0x1d, 0xca, 0xc6, 0x6d, 0x98, 0x6d, 0x32, 0xd7, 0x65, 0x5f,
	0x34, 0xda, 0x98, 0x60, 0x11, 0xcc, 0xf5, 0x9c, 0x6f, 0xdb, 0xf2, 0x4c, 0x95, 0xd7, 0xd5, 0x5c,
	0xde, 0x4e, 0xeb, 0x72, 0x99, 0x24, 0xf3, 0x48, 0x83, 0x42, 0x98, 0x5c, 0x69, 0xdb, 0x8c, 0x90,
	0x1e, 0x67, 0x0e, 0x95, 0x24, 0xe9, 0x4a, 0x92, 0x2a, 0x55, 0x55, 0x44, 0x79, 0x48, 0x43, 0xc4,
	0x39, 0x9b, 0xbf, 0xab, 0x92, 0xaa, 0x61, 0x9e, 0xc6, 0x2a, 0x29, 0x5e, 0x16, 0x5d, 0x2d, 0xcb,
	0xa8, 0x8a, 0x22, 0x94, 0x5f, 0xfb, 0x6e, 0x16, 0xf4, 0x1a, 0x6f, 0x19, 0x9f, 0x40, 0x2e, 0xfa,
	0x59, 0x61, 0x96, 0xd4, 0xef, 0xa2, 0x52, 0xff, 0xe6, 0x5e, 0x78, 0x79, 0x00, 0x26, 0xe9, 0xd3,
	0xc5, 0xb0, 0xe1, 0x5a, 0x6c, 0xc5, 0x7f, 0x29, 0xf5, 0xf1, 0xd1, 0xa2, 0x3c, 0x86, 0xab, 0xbd,
	0x35, 0x7c, 0x69, 0xb0, 0x04, 0x09, 0xc8, 0x76, 0xf2, 0xa7, 0x30, 0xaf, 0x6e, 0xa0, 0x2b, 0xa9,
	0x27, 0x44, 0x90, 0xd9, 0x62, 0xb9, 0x70, 0x3d, 0x79, 0xa9, 0x7a, 0x65, 0x78, 0xbc, 0x10, 0x7d,
	0x91, 0x98, 0x91, 0xed, 0xf4, 0x1c, 0x31, 0x43, 0x74, 0xb6, 0x98, 0x6d, 0x30, 0x12, 0xf6, 0xac,
	0x7b, 0x43, 0xea, 0x16, 0x42, 0x33, 0x2b, 0x4c, 0x5e, 0x87, 0x06, 0x29, 0x4c, 0x44, 0x8f, 0xa2,
	0x30, 0xbe, 0xb5, 0xa4, 0x28, 0x8c, 0x41, 0xb3, 0x45, 0xeb, 0x42, 0x7e, 0xe0, 0x26, 0x51, 0x4e,
	0x3d, 0x48, 0x7d, 0x20, 0x5b, 0xe4, 0xaf, 0x35, 0x58, 0x1a, 0x3a, 0xff, 0xb3, 0x30, 0x08, 0x9f,
	0xcb, 0x46, 0xe4, 0x09, 0xcc, 0x84, 0x53, 0x7a, 0x39, 0x25, 0xcf, 0x12, 0x91, 0xed, 0xec, 0x7d,
	0x58, 0x1c, 0x34, 0xcb, 0x4a, 0xe9, 0xda, 0xe2, 0xf8, 0x0b, 0xc5, 0x8d, 0x0e, 0x9c, 0xf3, 0xc4,
	0x8d, 0xe0, 0x33, 0xc5, 0x2d, 0x4c, 0x7d, 0x79, 0x7a, 0xb8, 0xaa, 0x55, 0x1f, 0xfd, 0x7a, 0x5c,
	0xd4, 0x8e, 0x8e, 0x8b, 0xda, 0xbf, 0xc7, 0x45, 0xed, 0xdb, 0x93, 0xe2, 0xc4, 0xd1, 0x49, 0x71,
	0xe2, 0xaf, 0x93, 0xe2, 0xc4, 0x93, 0xfb, 0x2d, 0x2c, 0xf6, 0x3a, 0xcd, 0xd2, 0x0e, 0x23, 0x72,
	0xee, 0xac, 0x11, 0x46, 0xd1, 0x41, 0xf2, 0x08, 0x12, 0x07, 0x0e, 0xe2, 0xcd, 0x69, 0xf9, 0x27,
	0xae, 0x07, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x72, 0xeb, 0xcc, 0x45, 0x93, 0x13, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	AddDEXDenom(ctx context.Context, in *MsgAddDEXDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateDEXDenom(ctx context.Context, in *MsgUpdateDEXDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	AddKCoin(ctx context.Context, in *MsgAddKCoin, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateKCoinSupply(ctx context.Context, in *MsgUpdateKCoinSupply, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateKCoinMintAmount(ctx context.Context, in *MsgUpdateKCoinMintAmount, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateKCoinBurnAmount(ctx context.Context, in *MsgUpdateKCoinBurnAmount, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	AddKCoinReferences(ctx context.Context, in *MsgAddKCoinReferences, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	RemoveKCoinReferences(ctx context.Context, in *MsgRemoveKCoinReferences, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	AddCollateralDenom(ctx context.Context, in *MsgAddCollateralDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateCollateralDenomLTV(ctx context.Context, in *MsgUpdateCollateralDenomLTV, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateCollateralDenomMaxDeposit(ctx context.Context, in *MsgUpdateCollateralDenomMaxDeposit, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	AddCAsset(ctx context.Context, in *MsgAddCAsset, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateCAssetDexFeeShare(ctx context.Context, in *MsgUpdateCAssetDexFeeShare, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	UpdateCAssetBorrowLimit(ctx context.Context, in *MsgUpdateCAssetBorrowLimit, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) AddDEXDenom(ctx context.Context, in *MsgAddDEXDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/AddDEXDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateDEXDenom(ctx context.Context, in *MsgUpdateDEXDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateDEXDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddKCoin(ctx context.Context, in *MsgAddKCoin, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/AddKCoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKCoinSupply(ctx context.Context, in *MsgUpdateKCoinSupply, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateKCoinSupply", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKCoinMintAmount(ctx context.Context, in *MsgUpdateKCoinMintAmount, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateKCoinMintAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKCoinBurnAmount(ctx context.Context, in *MsgUpdateKCoinBurnAmount, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateKCoinBurnAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddKCoinReferences(ctx context.Context, in *MsgAddKCoinReferences, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/AddKCoinReferences", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveKCoinReferences(ctx context.Context, in *MsgRemoveKCoinReferences, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/RemoveKCoinReferences", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddCollateralDenom(ctx context.Context, in *MsgAddCollateralDenom, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/AddCollateralDenom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCollateralDenomLTV(ctx context.Context, in *MsgUpdateCollateralDenomLTV, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateCollateralDenomLTV", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCollateralDenomMaxDeposit(ctx context.Context, in *MsgUpdateCollateralDenomMaxDeposit, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateCollateralDenomMaxDeposit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddCAsset(ctx context.Context, in *MsgAddCAsset, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/AddCAsset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCAssetDexFeeShare(ctx context.Context, in *MsgUpdateCAssetDexFeeShare, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateCAssetDexFeeShare", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCAssetBorrowLimit(ctx context.Context, in *MsgUpdateCAssetBorrowLimit, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/kopi.denominations.Msg/UpdateCAssetBorrowLimit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	AddDEXDenom(context.Context, *MsgAddDEXDenom) (*MsgUpdateParamsResponse, error)
	UpdateDEXDenom(context.Context, *MsgUpdateDEXDenom) (*MsgUpdateParamsResponse, error)
	AddKCoin(context.Context, *MsgAddKCoin) (*MsgUpdateParamsResponse, error)
	UpdateKCoinSupply(context.Context, *MsgUpdateKCoinSupply) (*MsgUpdateParamsResponse, error)
	UpdateKCoinMintAmount(context.Context, *MsgUpdateKCoinMintAmount) (*MsgUpdateParamsResponse, error)
	UpdateKCoinBurnAmount(context.Context, *MsgUpdateKCoinBurnAmount) (*MsgUpdateParamsResponse, error)
	AddKCoinReferences(context.Context, *MsgAddKCoinReferences) (*MsgUpdateParamsResponse, error)
	RemoveKCoinReferences(context.Context, *MsgRemoveKCoinReferences) (*MsgUpdateParamsResponse, error)
	AddCollateralDenom(context.Context, *MsgAddCollateralDenom) (*MsgUpdateParamsResponse, error)
	UpdateCollateralDenomLTV(context.Context, *MsgUpdateCollateralDenomLTV) (*MsgUpdateParamsResponse, error)
	UpdateCollateralDenomMaxDeposit(context.Context, *MsgUpdateCollateralDenomMaxDeposit) (*MsgUpdateParamsResponse, error)
	AddCAsset(context.Context, *MsgAddCAsset) (*MsgUpdateParamsResponse, error)
	UpdateCAssetDexFeeShare(context.Context, *MsgUpdateCAssetDexFeeShare) (*MsgUpdateParamsResponse, error)
	UpdateCAssetBorrowLimit(context.Context, *MsgUpdateCAssetBorrowLimit) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) AddDEXDenom(ctx context.Context, req *MsgAddDEXDenom) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddDEXDenom not implemented")
}
func (*UnimplementedMsgServer) UpdateDEXDenom(ctx context.Context, req *MsgUpdateDEXDenom) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDEXDenom not implemented")
}
func (*UnimplementedMsgServer) AddKCoin(ctx context.Context, req *MsgAddKCoin) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKCoin not implemented")
}
func (*UnimplementedMsgServer) UpdateKCoinSupply(ctx context.Context, req *MsgUpdateKCoinSupply) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKCoinSupply not implemented")
}
func (*UnimplementedMsgServer) UpdateKCoinMintAmount(ctx context.Context, req *MsgUpdateKCoinMintAmount) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKCoinMintAmount not implemented")
}
func (*UnimplementedMsgServer) UpdateKCoinBurnAmount(ctx context.Context, req *MsgUpdateKCoinBurnAmount) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKCoinBurnAmount not implemented")
}
func (*UnimplementedMsgServer) AddKCoinReferences(ctx context.Context, req *MsgAddKCoinReferences) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKCoinReferences not implemented")
}
func (*UnimplementedMsgServer) RemoveKCoinReferences(ctx context.Context, req *MsgRemoveKCoinReferences) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKCoinReferences not implemented")
}
func (*UnimplementedMsgServer) AddCollateralDenom(ctx context.Context, req *MsgAddCollateralDenom) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCollateralDenom not implemented")
}
func (*UnimplementedMsgServer) UpdateCollateralDenomLTV(ctx context.Context, req *MsgUpdateCollateralDenomLTV) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollateralDenomLTV not implemented")
}
func (*UnimplementedMsgServer) UpdateCollateralDenomMaxDeposit(ctx context.Context, req *MsgUpdateCollateralDenomMaxDeposit) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollateralDenomMaxDeposit not implemented")
}
func (*UnimplementedMsgServer) AddCAsset(ctx context.Context, req *MsgAddCAsset) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCAsset not implemented")
}
func (*UnimplementedMsgServer) UpdateCAssetDexFeeShare(ctx context.Context, req *MsgUpdateCAssetDexFeeShare) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCAssetDexFeeShare not implemented")
}
func (*UnimplementedMsgServer) UpdateCAssetBorrowLimit(ctx context.Context, req *MsgUpdateCAssetBorrowLimit) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCAssetBorrowLimit not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_AddDEXDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddDEXDenom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddDEXDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/AddDEXDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddDEXDenom(ctx, req.(*MsgAddDEXDenom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateDEXDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateDEXDenom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateDEXDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateDEXDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateDEXDenom(ctx, req.(*MsgUpdateDEXDenom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddKCoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddKCoin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddKCoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/AddKCoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddKCoin(ctx, req.(*MsgAddKCoin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKCoinSupply_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKCoinSupply)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKCoinSupply(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateKCoinSupply",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKCoinSupply(ctx, req.(*MsgUpdateKCoinSupply))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKCoinMintAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKCoinMintAmount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKCoinMintAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateKCoinMintAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKCoinMintAmount(ctx, req.(*MsgUpdateKCoinMintAmount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKCoinBurnAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKCoinBurnAmount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKCoinBurnAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateKCoinBurnAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKCoinBurnAmount(ctx, req.(*MsgUpdateKCoinBurnAmount))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddKCoinReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddKCoinReferences)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddKCoinReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/AddKCoinReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddKCoinReferences(ctx, req.(*MsgAddKCoinReferences))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveKCoinReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveKCoinReferences)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveKCoinReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/RemoveKCoinReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveKCoinReferences(ctx, req.(*MsgRemoveKCoinReferences))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddCollateralDenom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddCollateralDenom)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddCollateralDenom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/AddCollateralDenom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddCollateralDenom(ctx, req.(*MsgAddCollateralDenom))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCollateralDenomLTV_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCollateralDenomLTV)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCollateralDenomLTV(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateCollateralDenomLTV",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCollateralDenomLTV(ctx, req.(*MsgUpdateCollateralDenomLTV))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCollateralDenomMaxDeposit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCollateralDenomMaxDeposit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCollateralDenomMaxDeposit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateCollateralDenomMaxDeposit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCollateralDenomMaxDeposit(ctx, req.(*MsgUpdateCollateralDenomMaxDeposit))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddCAsset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddCAsset)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddCAsset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/AddCAsset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddCAsset(ctx, req.(*MsgAddCAsset))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCAssetDexFeeShare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCAssetDexFeeShare)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCAssetDexFeeShare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateCAssetDexFeeShare",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCAssetDexFeeShare(ctx, req.(*MsgUpdateCAssetDexFeeShare))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCAssetBorrowLimit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCAssetBorrowLimit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCAssetBorrowLimit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kopi.denominations.Msg/UpdateCAssetBorrowLimit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCAssetBorrowLimit(ctx, req.(*MsgUpdateCAssetBorrowLimit))
	}
	return interceptor(ctx, in, info, handler)
}

var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kopi.denominations.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddDEXDenom",
			Handler:    _Msg_AddDEXDenom_Handler,
		},
		{
			MethodName: "UpdateDEXDenom",
			Handler:    _Msg_UpdateDEXDenom_Handler,
		},
		{
			MethodName: "AddKCoin",
			Handler:    _Msg_AddKCoin_Handler,
		},
		{
			MethodName: "UpdateKCoinSupply",
			Handler:    _Msg_UpdateKCoinSupply_Handler,
		},
		{
			MethodName: "UpdateKCoinMintAmount",
			Handler:    _Msg_UpdateKCoinMintAmount_Handler,
		},
		{
			MethodName: "UpdateKCoinBurnAmount",
			Handler:    _Msg_UpdateKCoinBurnAmount_Handler,
		},
		{
			MethodName: "AddKCoinReferences",
			Handler:    _Msg_AddKCoinReferences_Handler,
		},
		{
			MethodName: "RemoveKCoinReferences",
			Handler:    _Msg_RemoveKCoinReferences_Handler,
		},
		{
			MethodName: "AddCollateralDenom",
			Handler:    _Msg_AddCollateralDenom_Handler,
		},
		{
			MethodName: "UpdateCollateralDenomLTV",
			Handler:    _Msg_UpdateCollateralDenomLTV_Handler,
		},
		{
			MethodName: "UpdateCollateralDenomMaxDeposit",
			Handler:    _Msg_UpdateCollateralDenomMaxDeposit_Handler,
		},
		{
			MethodName: "AddCAsset",
			Handler:    _Msg_AddCAsset_Handler,
		},
		{
			MethodName: "UpdateCAssetDexFeeShare",
			Handler:    _Msg_UpdateCAssetDexFeeShare_Handler,
		},
		{
			MethodName: "UpdateCAssetBorrowLimit",
			Handler:    _Msg_UpdateCAssetBorrowLimit_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "kopi/denominations/tx.proto",
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgAddDEXDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddDEXDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddDEXDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinLiquidity) > 0 {
		i -= len(m.MinLiquidity)
		copy(dAtA[i:], m.MinLiquidity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MinLiquidity)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Factor) > 0 {
		i -= len(m.Factor)
		copy(dAtA[i:], m.Factor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Factor)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateDEXDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateDEXDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateDEXDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinLiquidity) > 0 {
		i -= len(m.MinLiquidity)
		copy(dAtA[i:], m.MinLiquidity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MinLiquidity)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddKCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddKCoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddKCoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinLiquidity) > 0 {
		i -= len(m.MinLiquidity)
		copy(dAtA[i:], m.MinLiquidity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MinLiquidity)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Factor) > 0 {
		i -= len(m.Factor)
		copy(dAtA[i:], m.Factor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Factor)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MaxBurnAmount) > 0 {
		i -= len(m.MaxBurnAmount)
		copy(dAtA[i:], m.MaxBurnAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxBurnAmount)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.MaxMintAmount) > 0 {
		i -= len(m.MaxMintAmount)
		copy(dAtA[i:], m.MaxMintAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxMintAmount)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MaxSupply) > 0 {
		i -= len(m.MaxSupply)
		copy(dAtA[i:], m.MaxSupply)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxSupply)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.References) > 0 {
		for iNdEx := len(m.References) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.References[iNdEx])
			copy(dAtA[i:], m.References[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.References[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateKCoinSupply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateKCoinSupply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateKCoinSupply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxSupply) > 0 {
		i -= len(m.MaxSupply)
		copy(dAtA[i:], m.MaxSupply)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxSupply)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateKCoinBurnAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateKCoinBurnAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateKCoinBurnAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxBurnAmount) > 0 {
		i -= len(m.MaxBurnAmount)
		copy(dAtA[i:], m.MaxBurnAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxBurnAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateKCoinMintAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateKCoinMintAmount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateKCoinMintAmount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxMintAmount) > 0 {
		i -= len(m.MaxMintAmount)
		copy(dAtA[i:], m.MaxMintAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxMintAmount)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddKCoinReferences) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddKCoinReferences) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddKCoinReferences) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.References) > 0 {
		for iNdEx := len(m.References) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.References[iNdEx])
			copy(dAtA[i:], m.References[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.References[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRemoveKCoinReferences) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRemoveKCoinReferences) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRemoveKCoinReferences) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.References) > 0 {
		for iNdEx := len(m.References) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.References[iNdEx])
			copy(dAtA[i:], m.References[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.References[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddCollateralDenom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddCollateralDenom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddCollateralDenom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxDeposit) > 0 {
		i -= len(m.MaxDeposit)
		copy(dAtA[i:], m.MaxDeposit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxDeposit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Ltv) > 0 {
		i -= len(m.Ltv)
		copy(dAtA[i:], m.Ltv)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ltv)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollateralDenomLTV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollateralDenomLTV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollateralDenomLTV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ltv) > 0 {
		i -= len(m.Ltv)
		copy(dAtA[i:], m.Ltv)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Ltv)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCollateralDenomMaxDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCollateralDenomMaxDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCollateralDenomMaxDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxDeposit) > 0 {
		i -= len(m.MaxDeposit)
		copy(dAtA[i:], m.MaxDeposit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxDeposit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddCAsset) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddCAsset) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddCAsset) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BorrowLimit) > 0 {
		i -= len(m.BorrowLimit)
		copy(dAtA[i:], m.BorrowLimit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BorrowLimit)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MinLiquidity) > 0 {
		i -= len(m.MinLiquidity)
		copy(dAtA[i:], m.MinLiquidity)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MinLiquidity)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Factor) > 0 {
		i -= len(m.Factor)
		copy(dAtA[i:], m.Factor)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Factor)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DexFeeShare) > 0 {
		i -= len(m.DexFeeShare)
		copy(dAtA[i:], m.DexFeeShare)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DexFeeShare)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.BaseDenom) > 0 {
		i -= len(m.BaseDenom)
		copy(dAtA[i:], m.BaseDenom)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BaseDenom)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCAssetDexFeeShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCAssetDexFeeShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCAssetDexFeeShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DexFeeShare) > 0 {
		i -= len(m.DexFeeShare)
		copy(dAtA[i:], m.DexFeeShare)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DexFeeShare)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCAssetBorrowLimit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCAssetBorrowLimit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCAssetBorrowLimit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BorrowLimit) > 0 {
		i -= len(m.BorrowLimit)
		copy(dAtA[i:], m.BorrowLimit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.BorrowLimit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgAddDEXDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Factor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MinLiquidity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateDEXDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MinLiquidity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddKCoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.MaxSupply)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxMintAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxBurnAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Factor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MinLiquidity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateKCoinSupply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxSupply)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateKCoinBurnAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxBurnAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateKCoinMintAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxMintAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddKCoinReferences) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgRemoveKCoinReferences) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.References) > 0 {
		for _, s := range m.References {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgAddCollateralDenom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ltv)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxDeposit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCollateralDenomLTV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Ltv)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCollateralDenomMaxDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MaxDeposit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAddCAsset) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BaseDenom)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DexFeeShare)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Factor)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MinLiquidity)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BorrowLimit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCAssetDexFeeShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DexFeeShare)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCAssetBorrowLimit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.BorrowLimit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddDEXDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddDEXDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddDEXDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Factor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinLiquidity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateDEXDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateDEXDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateDEXDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinLiquidity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddKCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddKCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddKCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxSupply = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMintAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxMintAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxBurnAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Factor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinLiquidity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateKCoinSupply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateKCoinSupply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateKCoinSupply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSupply", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxSupply = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateKCoinBurnAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateKCoinBurnAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateKCoinBurnAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBurnAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxBurnAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateKCoinMintAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateKCoinMintAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateKCoinMintAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMintAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxMintAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddKCoinReferences) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddKCoinReferences: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddKCoinReferences: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRemoveKCoinReferences) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRemoveKCoinReferences: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRemoveKCoinReferences: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.References = append(m.References, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddCollateralDenom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddCollateralDenom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddCollateralDenom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ltv = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollateralDenomLTV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollateralDenomLTV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollateralDenomLTV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ltv", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ltv = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCollateralDenomMaxDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCollateralDenomMaxDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCollateralDenomMaxDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddCAsset) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddCAsset: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddCAsset: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexFeeShare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexFeeShare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Factor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Factor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLiquidity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinLiquidity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCAssetDexFeeShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCAssetDexFeeShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCAssetDexFeeShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexFeeShare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexFeeShare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCAssetBorrowLimit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCAssetBorrowLimit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCAssetBorrowLimit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BorrowLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BorrowLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
